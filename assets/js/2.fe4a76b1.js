(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{182:function(e,v,_){e.exports=_.p+"assets/img/image-20191209115719717.587b389a.jpg"},183:function(e,v,_){e.exports=_.p+"assets/img/image-20191209144233374.5228227f.jpg"},184:function(e,v,_){e.exports=_.p+"assets/img/image-20191209160818002.8465263e.jpg"},185:function(e,v,_){e.exports=_.p+"assets/img/image-20191209163737876.34dbd1ae.jpg"},186:function(e,v,_){e.exports=_.p+"assets/img/image-20191209164248740.d111ab34.jpg"},187:function(e,v,_){e.exports=_.p+"assets/img/image-20191209164708904.363c2f17.jpg"},188:function(e,v,_){e.exports=_.p+"assets/img/image-20191209165838621.fb7127e1.jpg"},189:function(e,v,_){e.exports=_.p+"assets/img/image-20191209170336366.f0f26681.jpg"},190:function(e,v,_){e.exports=_.p+"assets/img/image-20191209170545401.88d577e0.jpg"},191:function(e,v,_){e.exports=_.p+"assets/img/image-20191209171159936.0b9f5c97.jpg"},212:function(e,v,_){"use strict";_.r(v);var t=[function(){var e=this,v=e.$createElement,t=e._self._c||v;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"浏览器缓存机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存机制","aria-hidden":"true"}},[e._v("#")]),e._v(" 浏览器缓存机制")]),e._v(" "),t("h2",{attrs:{id:"什么是缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是缓存","aria-hidden":"true"}},[e._v("#")]),e._v(" 什么是缓存")]),e._v(" "),t("p",[e._v("​浏览器缓存（Browser Caching）是为了节约网络的资源加速浏览，浏览器在用户磁盘上对最近请求过的文档进行存储，当访问者再次请求这个页面时，浏览器就可以从本地磁盘显示文档，这样就可以加速页面的阅览。浏览器缓存主要有两类："),t("strong",[e._v("缓存协商")]),e._v(" 和 "),t("strong",[e._v("强缓存")]),e._v("。")]),e._v(" "),t("h2",{attrs:{id:"为什么要缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么要缓存","aria-hidden":"true"}},[e._v("#")]),e._v(" 为什么要缓存")]),e._v(" "),t("ul",[t("li",[e._v("减少冗余的数据传输，节省网络开销")]),e._v(" "),t("li",[e._v("缓解网络瓶颈问题，不占用更多的宽带就能更快的加载页面")]),e._v(" "),t("li",[e._v("降低了对原始服务器的要求，能更快的响应，避免过载出现")]),e._v(" "),t("li",[e._v("降低了距离时延，因为从较远的地方加载页面会慢一些")])]),e._v(" "),t("h2",{attrs:{id:"原理浅析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原理浅析","aria-hidden":"true"}},[e._v("#")]),e._v(" 原理浅析")]),e._v(" "),t("p",[t("img",{attrs:{src:_(182),alt:"image-20191209160818002"}})]),e._v(" "),t("p",[e._v("​现在有客户端浏览器（Client）和服务端（Server）。浏览器向服务器发送请求，获取一个文件（File），服务器收到请求后返回给浏览器一个 File。")]),e._v(" "),t("p",[e._v("​假设这个文件（File）的时效性不是那么强，而且文件内容也不会频繁的有改变，一周更新一次。这时候，浏览器如果每次请求服务器都返回相同的文件，这样就会造成对服务器资源的浪费。")]),e._v(" "),t("p",[e._v("​\t所以如何解决呢？")]),e._v(" "),t("p",[e._v("​如果浏览器把请求后得到的文件（File）存到本地，等下次再请求的时候，先查看本地是否有缓存文件，如果有，直接拿本地的文件，那这样就不用去访问源服务器了。这就是缓存的基本原理。")]),e._v(" "),t("p",[t("img",{attrs:{src:_(183),alt:"image-20191209144233374"}})]),e._v(" "),t("p",[e._v("​现在，我们把第一次请求到的文件（File）保存到浏览器的缓存中。等到下次浏览器再次请求这个文件（File）的时候，就直接从浏览器缓存的文件中拿，不再向服务器（Server）发起请求了。")]),e._v(" "),t("h2",{attrs:{id:"两种缓存方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#两种缓存方式","aria-hidden":"true"}},[e._v("#")]),e._v(" 两种缓存方式")]),e._v(" "),t("p",[e._v("​文件缓存在浏览器后，有自己的“新鲜度”（freshness limit）在这段时间里， 都认为文档是“新鲜的”，缓存可以在不联系服务器的情况下，直接提供该文档。但一旦已缓存副本停留的时间太长，超过了文档的新鲜度限值, 就认为对象“过时”了，在提供该文档之前，缓存要再次与服务器进行确认，以查看文档是否发生了变化。")]),e._v(" "),t("p",[e._v("​\t"),t("strong",[e._v("http")]),e._v(" 协议提供了两种维度来让缓存失效：时间（强缓存）和文件的修改（协商缓存）。")]),e._v(" "),t("h3",{attrs:{id:"通过时间判断“新鲜度”（强缓存）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#通过时间判断“新鲜度”（强缓存）","aria-hidden":"true"}},[e._v("#")]),e._v(" 通过时间判断“新鲜度”（强缓存）")]),e._v(" "),t("p",[e._v("​时间维度上，就是设定一个缓存时间，过了这个设定时间后，缓存被认为失效，浏览器就会对源服务器发起请求获取文件。这个 "),t("strong",[e._v("设定的时间")]),e._v(" 就是 "),t("strong",[e._v("http/1.1")]),e._v(" 字段的 "),t("code",[e._v("cache-control:max-age")]),e._v(" 和 "),t("strong",[e._v("http/1.0")]),e._v(" 的 "),t("code",[e._v("Expires")])]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Expires（HTTP/1.0）")])])]),e._v(" "),t("p",[t("strong",[e._v("例")]),e._v("："),t("code",[e._v("expires: Fri, 27 Dec 2019 09:31:12 GMT")])]),e._v(" "),t("p",[t("code",[e._v("Expires")]),e._v(" 描述的是一个绝对时间，由服务器返回，用 "),t("strong",[e._v("GMT")]),e._v(" 格式的字符串表示。由于 "),t("code",[e._v("Expires")]),e._v(" 是一个绝对时间，如果人为的更改时间，会对缓存的有效期造成影响，使缓存有效期的设置失去意义。因此在 "),t("strong",[e._v("http/1.1")]),e._v(" 有了 "),t("code",[e._v("cache-control:max-age")]),e._v(" 来代替。")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("Cache-Control（HTTP/1.1）")])])]),e._v(" "),t("p",[t("strong",[e._v("例")]),e._v("："),t("code",[e._v("cache-control: max-age=2592000")])]),e._v(" "),t("p",[t("code",[e._v("max-age")]),e._v(" 的值是一个相对时间，它定义了文件的最大使用期——从第一次生成文件到文件不再新鲜、无法使用文件，最大的合法生存时间（单位：秒）")]),e._v(" "),t("p",[t("code",[e._v("cache-control")]),e._v(" 可以设置的字段：")]),e._v(" "),t("ul",[t("li",[e._v("private ：客户端可以缓存")]),e._v(" "),t("li",[e._v("public ：客户端和代理服务器都可以缓存，大部分情况可认为 public 和 private 是一样的")]),e._v(" "),t("li",[e._v("max-age = xxx ：缓存的内容将在 xxx 秒后失效")]),e._v(" "),t("li",[e._v("no-cache ：需要使用另外一种 http 缓存策略来验证缓存数据")]),e._v(" "),t("li",[e._v("no-store ：所有缓存策略都不会进行（强缓存、协商缓存都不会）")])]),e._v(" "),t("p",[t("img",{attrs:{src:_(184),alt:"image-20191209160818002"}})]),e._v(" "),t("p",[e._v("​\t第一次对服务器发起请求，服务器在返回文件（File）的同时在 "),t("code",[e._v("Response Headers")]),e._v(" 中加入 "),t("code",[e._v("Cache-Control:max-age=60")]),e._v(" 的字段，说明，这个文件（File）只能在浏览器端保持新鲜 60 秒，在这 60 秒内，客户端再请求文件（File）时，都会直接从缓存中拿。")]),e._v(" "),t("p",[e._v("​\t60 秒过后，缓存失效，浏览器再请求文件（File）需要重新向源服务器发起请求。")]),e._v(" "),t("h3",{attrs:{id:"通过文件内容判断“新鲜度”（协商缓存）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#通过文件内容判断“新鲜度”（协商缓存）","aria-hidden":"true"}},[e._v("#")]),e._v(" 通过文件内容判断“新鲜度”（协商缓存）")]),e._v(" "),t("p",[e._v("​\t浏览器先请求服务获得文件后，服务器会返回该文件的最后修改时间 "),t("code",[e._v("Last-Modified")]),e._v(" ，作为文件的一个标识，下次浏览器请求的时候，会带着这个标识去请求(此时为 "),t("code",[e._v("If-Modified-Since")]),e._v(" )，然后服务器做校验，如果说时间标识 "),t("code",[e._v("If-Modified-Since")]),e._v(" 等于服务器的文件修改时间，则说明没有修改，返回304状态码，浏览器从缓存中获取文件，但是如果浏览器保存的时间标识 "),t("code",[e._v("If-Modified-Since")]),e._v(" 小于服务器端的文件修改时间，那么，说明文件发生了修改，浏览器就会重新获取新的文件。 （ "),t("code",[e._v("If-Modified-Since")]),e._v(" 的时间如果大于服务器端文件的时间，会被认为是错误的请求）")]),e._v(" "),t("p",[e._v("​\t如图，Client 向 Server 起请求，Server 返回文件的同时还会返回文件的最后修改时间 "),t("code",[e._v("Last-Modified")]),e._v(" 作为文件时间标识，Client 会将文件和文件时间标识都缓存起来。")]),e._v(" "),t("p",[t("img",{attrs:{src:_(185),alt:"image-20191209163737876"}})]),e._v(" "),t("p",[e._v("​假如服务器端的文件（File）并没有被修改，服务器通过判断请求头带的时间标识 "),t("code",[e._v("If-Modified-Since")]),e._v(" 得出结论后，都会返回状态码 "),t("code",[e._v("304")]),e._v(" 告诉浏览器文件没有被修改，让浏览器使用缓存。")]),e._v(" "),t("p",[t("img",{attrs:{src:_(186),alt:"image-20191209164248740"}})]),e._v(" "),t("p",[e._v("​\t假如服务器端的文件（File）修改了，那么，浏览器将重新获取文件，并缓存到浏览器中。")]),e._v(" "),t("p",[t("img",{attrs:{src:_(187),alt:"image-20191209164708904"}})]),e._v(" "),t("p",[e._v("​虽然通过文件最后修改时间作为标识已经很完美了，但是，还是可能存在一个问题：就是有可能服务器端的文件修改后，又改回原来的样子，这样，虽然文件最后修改时间变了，但是，文件内容并没有改变。这样还是会有多余的请求到达服务器，该如何处理呢？")]),e._v(" "),t("p",[e._v("​可以将文件内容作为一个唯一标识，例如可以对文件内容取 "),t("strong",[e._v("哈希值")]),e._v(" 值作为字段( "),t("code",[e._v("etag")]),e._v(" )也传给浏览器端，假如这个文件内容没变化，那么 "),t("strong",[e._v("哈希值")]),e._v(" 值也不会改变。那么，处理流程就变成了这样：服务器端先判断文件修改时间是否发生了变化，如果发生了变化，那么再对比浏览器传来的 "),t("code",[e._v("If-None-Match")]),e._v(" 即浏览器端保留的 "),t("code",[e._v("E-tag")]),e._v(" 值，如果发生了变化，则证明文件修改了，需要浏览器重新下载文件，如果没有，则证明文件内容没变化，返回304状态码。")]),e._v(" "),t("p",[e._v("​当浏览器要访问服务器的文件（File），服务器返回了文件最后修改时间 "),t("code",[e._v("Last-Modified")]),e._v(" 和文件（File）的内容标识 "),t("code",[e._v("E-tag")]),e._v(" ，浏览器将这两个字段及其文件（File）缓存了起来。")]),e._v(" "),t("p",[t("img",{attrs:{src:_(188),alt:"image-20191209165838621"}})]),e._v(" "),t("p",[e._v("当文件最后 "),t("strong",[e._v("修改时间")]),e._v(" 没变，"),t("strong",[e._v("文件内容")]),e._v(" 也没变的时候，返回304，让浏览器从缓存中拿取文件（File）。")]),e._v(" "),t("p",[t("img",{attrs:{src:_(189),alt:"image-20191209170336366"}})]),e._v(" "),t("p",[e._v("当文件最后 "),t("strong",[e._v("修改时间")]),e._v(" 变了，"),t("strong",[e._v("文件内容")]),e._v(" 没变的时候，返回304，让浏览器从缓存中拿取文件（File）。")]),e._v(" "),t("p",[t("img",{attrs:{src:_(190),alt:"image-20191209170545401"}})]),e._v(" "),t("p",[e._v("当文件 "),t("strong",[e._v("修改时间")]),e._v(" 变了，"),t("strong",[e._v("文件内容")]),e._v(" 也变了的时候，服务器会重新下发新的文件（File）给浏览器。浏览器把返回的字段的新值保存，留下次请求时使用")]),e._v(" "),t("p",[t("img",{attrs:{src:_(191),alt:"image-20191209171159936"}})]),e._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结","aria-hidden":"true"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),t("p",[e._v("​\t时间维度上：")]),e._v(" "),t("ul",[t("li",[e._v("Response-Headers："),t("code",[e._v("Last-Modified")]),e._v("、"),t("code",[e._v("Expires")])]),e._v(" "),t("li",[e._v("Request-Headers："),t("code",[e._v("If-Modified-Since")])])]),e._v(" "),t("p",[e._v("​\t文件内容维度：")]),e._v(" "),t("ul",[t("li",[e._v("Response-Headers："),t("code",[e._v("E-tag")])]),e._v(" "),t("li",[e._v("Request-Headers："),t("code",[e._v("If-None-Match")])])]),e._v(" "),t("p",[e._v("​\t优先级：")]),e._v(" "),t("p",[e._v("​\t"),t("code",[e._v("Cache-Control")]),e._v(" > "),t("code",[e._v("Expires")])]),e._v(" "),t("p",[e._v("​\t"),t("code",[e._v("Etag")]),e._v(" > "),t("code",[e._v("Last-Modified")])]),e._v(" "),t("h3",{attrs:{id:"tips"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tips","aria-hidden":"true"}},[e._v("#")]),e._v(" Tips")]),e._v(" "),t("p",[e._v("​有时候需要不那么精确的资源标记验证方法。例如，某服务器想对一个很大且被广泛缓存的资源做微小的修改，但又不想再缓存服务器再验证时产生很大的传输流量。该情况下，服务器可以在标记前面家上 "),t("code",[e._v("W/")]),e._v(" 来广播一个“弱”实体标记。对于弱实体标记，只有关联的资源发生 "),t("strong",[e._v("重大改变")]),e._v(" 时，标记才会变化。而强实体标记则不管实体发生什么性质变化，标记都一定会改变。")])])}],a=_(0),i=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},t,!1,null,null,null);v.default=i.exports}}]);