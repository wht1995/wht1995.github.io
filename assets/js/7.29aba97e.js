(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{180:function(_,v,t){_.exports=t.p+"assets/img/connect.845b3d81.png"},181:function(_,v,t){_.exports=t.p+"assets/img/disConnect.30249e5a.png"},211:function(_,v,t){"use strict";t.r(v);var r=[function(){var _=this,v=_.$createElement,r=_._self._c||v;return r("div",{staticClass:"content"},[r("h1",{attrs:{id:"tcp-三次握手四次挥手"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#tcp-三次握手四次挥手","aria-hidden":"true"}},[_._v("#")]),_._v(" Tcp 三次握手四次挥手")]),_._v(" "),r("p",[_._v("TC 是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在 TCP/IP 协议中，TCP 协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。")]),_._v(" "),r("h2",{attrs:{id:"三次握手"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#三次握手","aria-hidden":"true"}},[_._v("#")]),_._v(" 三次握手")]),_._v(" "),r("p",[r("img",{attrs:{src:t(180),alt:"tcp_connect"}})]),_._v(" "),r("ul",[r("li",[r("p",[_._v("第一次握手，客户端发送 "),r("strong",[_._v("SYN")]),_._v(" 包到服务器，表示自己想要请求连接，并进入 "),r("strong",[_._v("SYN_SENT")]),_._v("（发送）状态，等待服务器确认。")])]),_._v(" "),r("li",[r("p",[_._v("第二次握手，服务器接收到 "),r("strong",[_._v("SYN")]),_._v(" 包后，告诉客户端“我已经收到了”，确认客户端的 "),r("strong",[_._v("SYN（ack=x+1）")]),_._v("，同时自己也发一个 "),r("strong",[_._v("SYN")]),_._v(" 包，即"),r("strong",[_._v("SYN + ACK")]),_._v(" 包，此时服务器进入 "),r("strong",[_._v("SYN_RECV")]),_._v("（接收）状态。")])]),_._v(" "),r("li",[r("p",[_._v("第三次握手，客户端收到服务器的 "),r("strong",[_._v("SYN + ACK")]),_._v(" 包后，需要向服务确认“我已经收到了”，然后向服务器发送确认包 "),r("strong",[_._v("ACK(ack=y+1)")]),_._v(" ，发送完毕后，客户端和服务器进入 "),r("strong",[_._v("ESTABLISHED")]),_._v("（已建立）状态，完成三次握手。")])])]),_._v(" "),r("p",[r("strong",[_._v("说明")]),_._v(" ：")]),_._v(" "),r("p",[_._v("① "),r("strong",[_._v("SYN")]),_._v(" 和 "),r("strong",[_._v("ACK")]),_._v(" 是标志位（0或1），"),r("strong",[_._v("ACK = 1")]),_._v(" 表示 "),r("strong",[_._v("ack")]),_._v(" 有效，"),r("strong",[_._v("seq")]),_._v(" 是序列号，"),r("strong",[_._v("ack")]),_._v(" 是确认号")]),_._v(" "),r("p",[_._v("② 给对方确认的方式就是把对方传来的 "),r("strong",[_._v("seq + 1")]),_._v(" 并赋值给 "),r("strong",[_._v("ack")])]),_._v(" "),r("h2",{attrs:{id:"四次挥手"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手","aria-hidden":"true"}},[_._v("#")]),_._v(" 四次挥手")]),_._v(" "),r("p",[r("img",{attrs:{src:t(181),alt:"tcp_release"}})]),_._v(" "),r("ul",[r("li",[_._v("客户端发送释放连接报文 "),r("strong",[_._v("FIN")]),_._v(" ，并停止发送数据。此时，客户端进入 "),r("strong",[_._v("FIN-WAIT-1")]),_._v("（终止等待1）状态。")]),_._v(" "),r("li",[_._v("服务器收到 "),r("strong",[_._v("连接释放报文")]),_._v(" 后，需要告诉客户端“我收到了”，于是发出确认报文，"),r("strong",[_._v("ACK=1")]),_._v("，"),r("strong",[_._v("ack=u+1")]),_._v("，并且带上自己的序列号 "),r("strong",[_._v("seq=v")]),_._v("，此时，服务端就进入了 "),r("strong",[_._v("CLOSE-WAIT")]),_._v("（关闭等待）状态。并且TCP服务器通知高层的应用进程，客户端向服务器请求断开连接了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个 "),r("strong",[_._v("CLOSE-WAIT")]),_._v(" 状态持续的时间。")]),_._v(" "),r("li",[_._v("客户端收到来自服务端的确认报文后，便进入到了 "),r("strong",[_._v("FIN-WAIT-2")]),_._v(" （终止等待2）状态，并等待服务端发来释放连接报文（在这之前还需要接受服务器发送的最后的数据）。")]),_._v(" "),r("li",[_._v("服务器将最后的数据发送完毕后，就向客户端发送连 "),r("strong",[_._v("接释放报文")]),_._v("，"),r("strong",[_._v("FIN=1")]),_._v("，"),r("strong",[_._v("ack=u+1")]),_._v("，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 "),r("strong",[_._v("seq=w")]),_._v("，此时，服务器就进入了 "),r("strong",[_._v("LAST-ACK")]),_._v("（最后确认）状态，等待客户端的确认。")]),_._v(" "),r("li",[_._v("客户端收到服务器的 "),r("strong",[_._v("连接释放报文")]),_._v(" 后，必须告诉服务器“我收到了”，于是必须发出确认，"),r("strong",[_._v("ACK=1")]),_._v("，"),r("strong",[_._v("ack=w+1")]),_._v("，而自己的序列号是 "),r("strong",[_._v("seq=u+1")]),_._v("，此时，客户端就进入了 "),r("strong",[_._v("TIME-WAIT")]),_._v("（时间等待）状态。注意此时TCP连接 "),r("strong",[_._v("还没有释放")]),_._v("，必须经过 "),r("strong",[_._v("2MSL")]),_._v("（最长报文段寿命）的时间后，当客户端撤销相应的 "),r("strong",[_._v("TCB")]),_._v("后，才进入CLOSED状态。")]),_._v(" "),r("li",[_._v("服务器只要收到了客户端发出的确认，立即进入 "),r("strong",[_._v("CLOSED")]),_._v(" 状态。撤销 "),r("strong",[_._v("TCB")]),_._v(" 后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。")])]),_._v(" "),r("p",[r("strong",[_._v("说明：")]),_._v(" "),r("strong",[_._v("TCB")]),_._v(" 是指创建的传输控制块")]),_._v(" "),r("h3",{attrs:{id:"直白点帮助理解"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#直白点帮助理解","aria-hidden":"true"}},[_._v("#")]),_._v(" 直白点帮助理解")]),_._v(" "),r("p",[_._v("假设客户端发起中断连接请求，也就是发送 FIN 报文。服务端接到FIN报文后，意思是说 "),r("strong",[_._v("“我客户端没有数据要发给你了”")]),_._v("，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，"),r("strong",[_._v('"告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息"')]),_._v("。这个时候客户端就进入FIN_WAIT 状态，继续等待服务端的 FIN 报文。当服务端确定数据已发送完成，则向客户端发送 FIN 报文，"),r("strong",[_._v('"告诉客户端，好了，我这边数据发完了，准备好关闭连接了"')]),_._v("。客户端收到 FIN 报文后，"),r("strong",[_._v('"就知道可以关闭连接了，但是他还是不相信网络，怕服务端不知道要关闭，所以发送 ACK 后进入 TIME_WAIT 状态，如果服务端没有收到ACK 则可以重传。“')]),_._v("，服务端收到 ACK 后，"),r("strong",[_._v('"就知道可以断开连接了"')]),_._v("。客户端等待了 2MSL 后依然没有收到回复，则证明服务端已正常关闭，那好，我客户端也可以关闭连接了。Ok，TCP连接就这样关闭了！")]),_._v(" "),r("h2",{attrs:{id:"常见问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#常见问题","aria-hidden":"true"}},[_._v("#")]),_._v(" 常见问题")]),_._v(" "),r("p",[r("strong",[_._v("Q: 为什么连接的时候是三次握手，关闭的时候却是四次握手？")])]),_._v(" "),r("p",[r("strong",[_._v("A:")]),_._v("  当客户端向服务端发送 SYN 报文请求连接时，这时没有数据传输，所以服务端可以发送一个 ACK + SYN 的报文给客户端。但是在关闭连接时，在此之前有进行数据传输，当客户端发送 FIN 请求断开连接时，很可能因为服务端还有数据没发给客户端，所以只能先回复一个 ACK 报文，告诉客户端“我收到你的断开请求了，但是我还有一些数据没发送完，所以我需要发完数据后再给你发 FIN 报文”，所以就需要四步。")]),_._v(" "),r("p",[r("strong",[_._v("Q: 为什么TIME_WAIT状态需要经过 2MSL (最大报文段生存时间)才能返回到 CLOSE 状态？")])]),_._v(" "),r("p",[r("strong",[_._v("A:")]),_._v("  讲道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可能客户端发送的最后一个 ACK 丢失。所以 TIME_WAIT状态就是用来重发可能丢失的 ACK 报文。在客户端发送出最后的 ACK 回复时，该ACK可能丢失。服务端如果没有收到 ACK，将不断重复发送 FIN 片段。所以客户端不能立即关闭，它必须确认服务端接收到了该 ACK 。客户端会在发送出 ACK 之后进入到 TIME_WAIT 状态。客户端会设置一个计时器，等待 2MSL 的时间。如果在该时间内再次收到来自服务端的 FIN，那么客户端会重发 ACK 并再次等待 2MSL。所谓的 2MSL 是两倍的 MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，客户端都没有再次收到来自服务端的 FIN，那么客户推断 ACK 已经被服务端成功接收，则结束TCP连接。")]),_._v(" "),r("p",[r("strong",[_._v("Q: 如果已经建立了连接，但是客户端突然出现故障了怎么办？")])]),_._v(" "),r("p",[r("strong",[_._v("A:")]),_._v(" TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。")]),_._v(" "),r("p",[r("strong",[_._v("Q: 为什么不能用两次握手进行连接？")])]),_._v(" "),r("p",[r("strong",[_._v("A:")]),_._v(" 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。")]),_._v(" "),r("p",[r("strong",[_._v("举例：")]),_._v(" “已失效的连接请求报文段”的产生在这样一种情况下：client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server由于收不到确认，就知道 client 并没有要求建立连接。”")]),_._v(" "),r("p",[_._v("这就很明白了，防止了服务器端的一直等待而浪费资源。")])])}],s=t(0),n=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},r,!1,null,null,null);v.default=n.exports}}]);