<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>浏览器缓存机制 | VC&#39;s Blog</title>
    <meta name="description" content="记录一下叭🐌">
    
    
    <link rel="preload" href="/assets/css/0.styles.058b2d67.css" as="style"><link rel="preload" href="/assets/js/app.3d620a6f.js" as="script"><link rel="preload" href="/assets/js/2.fe4a76b1.js" as="script"><link rel="prefetch" href="/assets/js/10.0ab68627.js"><link rel="prefetch" href="/assets/js/11.79396d94.js"><link rel="prefetch" href="/assets/js/12.c84ca706.js"><link rel="prefetch" href="/assets/js/13.cc9287f8.js"><link rel="prefetch" href="/assets/js/14.69138d78.js"><link rel="prefetch" href="/assets/js/15.971bb51c.js"><link rel="prefetch" href="/assets/js/16.1e10d839.js"><link rel="prefetch" href="/assets/js/17.e96aff6e.js"><link rel="prefetch" href="/assets/js/18.5ee51ef9.js"><link rel="prefetch" href="/assets/js/19.dfabf67f.js"><link rel="prefetch" href="/assets/js/20.45e6fa32.js"><link rel="prefetch" href="/assets/js/21.9d90f167.js"><link rel="prefetch" href="/assets/js/22.bc222999.js"><link rel="prefetch" href="/assets/js/23.50e02b83.js"><link rel="prefetch" href="/assets/js/24.196726eb.js"><link rel="prefetch" href="/assets/js/25.35b23e5c.js"><link rel="prefetch" href="/assets/js/26.30b67b5e.js"><link rel="prefetch" href="/assets/js/27.dd5f26e2.js"><link rel="prefetch" href="/assets/js/28.5bb22549.js"><link rel="prefetch" href="/assets/js/29.cd1a78d5.js"><link rel="prefetch" href="/assets/js/3.b6b016ad.js"><link rel="prefetch" href="/assets/js/30.a08bb659.js"><link rel="prefetch" href="/assets/js/31.b6a25c09.js"><link rel="prefetch" href="/assets/js/4.975d3a1f.js"><link rel="prefetch" href="/assets/js/5.e5a53480.js"><link rel="prefetch" href="/assets/js/6.3c214a26.js"><link rel="prefetch" href="/assets/js/7.29aba97e.js"><link rel="prefetch" href="/assets/js/8.2c61a77c.js"><link rel="prefetch" href="/assets/js/9.c38e0b2c.js">
    <link rel="stylesheet" href="/assets/css/0.styles.058b2d67.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">VC's Blog</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">notes</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/js/" class="nav-link">javaScript</a></li><li class="dropdown-item"><!----> <a href="/html/" class="nav-link">HTML/CSS</a></li><li class="dropdown-item"><!----> <a href="/http/" class="nav-link router-link-active">Http/浏览器/性能</a></li><li class="dropdown-item"><h4>后端</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/nodejs/" class="nav-link">NodeJs</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/about.html" class="nav-link">About</a></div><div class="nav-item"><a href="https://github.com/wht1995" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">notes</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/js/" class="nav-link">javaScript</a></li><li class="dropdown-item"><!----> <a href="/html/" class="nav-link">HTML/CSS</a></li><li class="dropdown-item"><!----> <a href="/http/" class="nav-link router-link-active">Http/浏览器/性能</a></li><li class="dropdown-item"><h4>后端</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/nodejs/" class="nav-link">NodeJs</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/about.html" class="nav-link">About</a></div><div class="nav-item"><a href="https://github.com/wht1995" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/http/" class="sidebar-link">这是HTTP的首页呀</a></li><li><a href="/http/tcp_3and4.html" class="sidebar-link">Tcp 三次握手四次挥手</a></li><li><a href="/http/浏览器缓存机制.html" class="active sidebar-link">浏览器缓存机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/http/浏览器缓存机制.html#什么是缓存" class="sidebar-link">什么是缓存</a></li><li class="sidebar-sub-header"><a href="/http/浏览器缓存机制.html#为什么要缓存" class="sidebar-link">为什么要缓存</a></li><li class="sidebar-sub-header"><a href="/http/浏览器缓存机制.html#原理浅析" class="sidebar-link">原理浅析</a></li><li class="sidebar-sub-header"><a href="/http/浏览器缓存机制.html#两种缓存方式" class="sidebar-link">两种缓存方式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/http/浏览器缓存机制.html#通过时间判断“新鲜度”（强缓存）" class="sidebar-link">通过时间判断“新鲜度”（强缓存）</a></li><li class="sidebar-sub-header"><a href="/http/浏览器缓存机制.html#通过文件内容判断“新鲜度”（协商缓存）" class="sidebar-link">通过文件内容判断“新鲜度”（协商缓存）</a></li></ul></li><li class="sidebar-sub-header"><a href="/http/浏览器缓存机制.html#总结" class="sidebar-link">总结</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/http/浏览器缓存机制.html#tips" class="sidebar-link">Tips</a></li></ul></li></ul></li><li><a href="/http/记一次性能优化.html" class="sidebar-link">记一次性能优化</a></li><li><a href="/http/cookie.html" class="sidebar-link">前端存储</a></li><li><a href="/http/XSS.html" class="sidebar-link">XSS 攻击</a></li><li><a href="/http/CSRF.html" class="sidebar-link">CSRF 攻击</a></li><li><div class="sidebar-group collapsable"><p class="sidebar-heading"><span>http基础</span> <span class="arrow right"></span></p> <!----></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="浏览器缓存机制"><a href="#浏览器缓存机制" aria-hidden="true" class="header-anchor">#</a> 浏览器缓存机制</h1> <h2 id="什么是缓存"><a href="#什么是缓存" aria-hidden="true" class="header-anchor">#</a> 什么是缓存</h2> <p>​浏览器缓存（Browser Caching）是为了节约网络的资源加速浏览，浏览器在用户磁盘上对最近请求过的文档进行存储，当访问者再次请求这个页面时，浏览器就可以从本地磁盘显示文档，这样就可以加速页面的阅览。浏览器缓存主要有两类：<strong>缓存协商</strong> 和 <strong>强缓存</strong>。</p> <h2 id="为什么要缓存"><a href="#为什么要缓存" aria-hidden="true" class="header-anchor">#</a> 为什么要缓存</h2> <ul><li>减少冗余的数据传输，节省网络开销</li> <li>缓解网络瓶颈问题，不占用更多的宽带就能更快的加载页面</li> <li>降低了对原始服务器的要求，能更快的响应，避免过载出现</li> <li>降低了距离时延，因为从较远的地方加载页面会慢一些</li></ul> <h2 id="原理浅析"><a href="#原理浅析" aria-hidden="true" class="header-anchor">#</a> 原理浅析</h2> <p><img src="/assets/img/image-20191209115719717.587b389a.jpg" alt="image-20191209160818002"></p> <p>​现在有客户端浏览器（Client）和服务端（Server）。浏览器向服务器发送请求，获取一个文件（File），服务器收到请求后返回给浏览器一个 File。</p> <p>​假设这个文件（File）的时效性不是那么强，而且文件内容也不会频繁的有改变，一周更新一次。这时候，浏览器如果每次请求服务器都返回相同的文件，这样就会造成对服务器资源的浪费。</p> <p>​	所以如何解决呢？</p> <p>​如果浏览器把请求后得到的文件（File）存到本地，等下次再请求的时候，先查看本地是否有缓存文件，如果有，直接拿本地的文件，那这样就不用去访问源服务器了。这就是缓存的基本原理。</p> <p><img src="/assets/img/image-20191209144233374.5228227f.jpg" alt="image-20191209144233374"></p> <p>​现在，我们把第一次请求到的文件（File）保存到浏览器的缓存中。等到下次浏览器再次请求这个文件（File）的时候，就直接从浏览器缓存的文件中拿，不再向服务器（Server）发起请求了。</p> <h2 id="两种缓存方式"><a href="#两种缓存方式" aria-hidden="true" class="header-anchor">#</a> 两种缓存方式</h2> <p>​文件缓存在浏览器后，有自己的“新鲜度”（freshness limit）在这段时间里， 都认为文档是“新鲜的”，缓存可以在不联系服务器的情况下，直接提供该文档。但一旦已缓存副本停留的时间太长，超过了文档的新鲜度限值, 就认为对象“过时”了，在提供该文档之前，缓存要再次与服务器进行确认，以查看文档是否发生了变化。</p> <p>​	<strong>http</strong> 协议提供了两种维度来让缓存失效：时间（强缓存）和文件的修改（协商缓存）。</p> <h3 id="通过时间判断“新鲜度”（强缓存）"><a href="#通过时间判断“新鲜度”（强缓存）" aria-hidden="true" class="header-anchor">#</a> 通过时间判断“新鲜度”（强缓存）</h3> <p>​时间维度上，就是设定一个缓存时间，过了这个设定时间后，缓存被认为失效，浏览器就会对源服务器发起请求获取文件。这个 <strong>设定的时间</strong> 就是 <strong>http/1.1</strong> 字段的 <code>cache-control:max-age</code> 和 <strong>http/1.0</strong> 的 <code>Expires</code></p> <ul><li><strong>Expires（HTTP/1.0）</strong></li></ul> <p><strong>例</strong>：<code>expires: Fri, 27 Dec 2019 09:31:12 GMT</code></p> <p><code>Expires</code> 描述的是一个绝对时间，由服务器返回，用 <strong>GMT</strong> 格式的字符串表示。由于 <code>Expires</code> 是一个绝对时间，如果人为的更改时间，会对缓存的有效期造成影响，使缓存有效期的设置失去意义。因此在 <strong>http/1.1</strong> 有了 <code>cache-control:max-age</code> 来代替。</p> <ul><li><strong>Cache-Control（HTTP/1.1）</strong></li></ul> <p><strong>例</strong>：<code>cache-control: max-age=2592000</code></p> <p><code>max-age</code> 的值是一个相对时间，它定义了文件的最大使用期——从第一次生成文件到文件不再新鲜、无法使用文件，最大的合法生存时间（单位：秒）</p> <p><code>cache-control</code> 可以设置的字段：</p> <ul><li>private ：客户端可以缓存</li> <li>public ：客户端和代理服务器都可以缓存，大部分情况可认为 public 和 private 是一样的</li> <li>max-age = xxx ：缓存的内容将在 xxx 秒后失效</li> <li>no-cache ：需要使用另外一种 http 缓存策略来验证缓存数据</li> <li>no-store ：所有缓存策略都不会进行（强缓存、协商缓存都不会）</li></ul> <p><img src="/assets/img/image-20191209160818002.8465263e.jpg" alt="image-20191209160818002"></p> <p>​	第一次对服务器发起请求，服务器在返回文件（File）的同时在 <code>Response Headers</code> 中加入 <code>Cache-Control:max-age=60</code> 的字段，说明，这个文件（File）只能在浏览器端保持新鲜 60 秒，在这 60 秒内，客户端再请求文件（File）时，都会直接从缓存中拿。</p> <p>​	60 秒过后，缓存失效，浏览器再请求文件（File）需要重新向源服务器发起请求。</p> <h3 id="通过文件内容判断“新鲜度”（协商缓存）"><a href="#通过文件内容判断“新鲜度”（协商缓存）" aria-hidden="true" class="header-anchor">#</a> 通过文件内容判断“新鲜度”（协商缓存）</h3> <p>​	浏览器先请求服务获得文件后，服务器会返回该文件的最后修改时间 <code>Last-Modified</code> ，作为文件的一个标识，下次浏览器请求的时候，会带着这个标识去请求(此时为 <code>If-Modified-Since</code> )，然后服务器做校验，如果说时间标识 <code>If-Modified-Since</code> 等于服务器的文件修改时间，则说明没有修改，返回304状态码，浏览器从缓存中获取文件，但是如果浏览器保存的时间标识 <code>If-Modified-Since</code> 小于服务器端的文件修改时间，那么，说明文件发生了修改，浏览器就会重新获取新的文件。 （ <code>If-Modified-Since</code> 的时间如果大于服务器端文件的时间，会被认为是错误的请求）</p> <p>​	如图，Client 向 Server 起请求，Server 返回文件的同时还会返回文件的最后修改时间 <code>Last-Modified</code> 作为文件时间标识，Client 会将文件和文件时间标识都缓存起来。</p> <p><img src="/assets/img/image-20191209163737876.34dbd1ae.jpg" alt="image-20191209163737876"></p> <p>​假如服务器端的文件（File）并没有被修改，服务器通过判断请求头带的时间标识 <code>If-Modified-Since</code> 得出结论后，都会返回状态码 <code>304</code> 告诉浏览器文件没有被修改，让浏览器使用缓存。</p> <p><img src="/assets/img/image-20191209164248740.d111ab34.jpg" alt="image-20191209164248740"></p> <p>​	假如服务器端的文件（File）修改了，那么，浏览器将重新获取文件，并缓存到浏览器中。</p> <p><img src="/assets/img/image-20191209164708904.363c2f17.jpg" alt="image-20191209164708904"></p> <p>​虽然通过文件最后修改时间作为标识已经很完美了，但是，还是可能存在一个问题：就是有可能服务器端的文件修改后，又改回原来的样子，这样，虽然文件最后修改时间变了，但是，文件内容并没有改变。这样还是会有多余的请求到达服务器，该如何处理呢？</p> <p>​可以将文件内容作为一个唯一标识，例如可以对文件内容取 <strong>哈希值</strong> 值作为字段( <code>etag</code> )也传给浏览器端，假如这个文件内容没变化，那么 <strong>哈希值</strong> 值也不会改变。那么，处理流程就变成了这样：服务器端先判断文件修改时间是否发生了变化，如果发生了变化，那么再对比浏览器传来的 <code>If-None-Match</code> 即浏览器端保留的 <code>E-tag</code> 值，如果发生了变化，则证明文件修改了，需要浏览器重新下载文件，如果没有，则证明文件内容没变化，返回304状态码。</p> <p>​当浏览器要访问服务器的文件（File），服务器返回了文件最后修改时间 <code>Last-Modified</code> 和文件（File）的内容标识 <code>E-tag</code> ，浏览器将这两个字段及其文件（File）缓存了起来。</p> <p><img src="/assets/img/image-20191209165838621.fb7127e1.jpg" alt="image-20191209165838621"></p> <p>当文件最后 <strong>修改时间</strong> 没变，<strong>文件内容</strong> 也没变的时候，返回304，让浏览器从缓存中拿取文件（File）。</p> <p><img src="/assets/img/image-20191209170336366.f0f26681.jpg" alt="image-20191209170336366"></p> <p>当文件最后 <strong>修改时间</strong> 变了，<strong>文件内容</strong> 没变的时候，返回304，让浏览器从缓存中拿取文件（File）。</p> <p><img src="/assets/img/image-20191209170545401.88d577e0.jpg" alt="image-20191209170545401"></p> <p>当文件 <strong>修改时间</strong> 变了，<strong>文件内容</strong> 也变了的时候，服务器会重新下发新的文件（File）给浏览器。浏览器把返回的字段的新值保存，留下次请求时使用</p> <p><img src="/assets/img/image-20191209171159936.0b9f5c97.jpg" alt="image-20191209171159936"></p> <h2 id="总结"><a href="#总结" aria-hidden="true" class="header-anchor">#</a> 总结</h2> <p>​	时间维度上：</p> <ul><li>Response-Headers：<code>Last-Modified</code>、<code>Expires</code></li> <li>Request-Headers：<code>If-Modified-Since</code></li></ul> <p>​	文件内容维度：</p> <ul><li>Response-Headers：<code>E-tag</code></li> <li>Request-Headers：<code>If-None-Match</code></li></ul> <p>​	优先级：</p> <p>​	<code>Cache-Control</code> &gt; <code>Expires</code></p> <p>​	<code>Etag</code> &gt; <code>Last-Modified</code></p> <h3 id="tips"><a href="#tips" aria-hidden="true" class="header-anchor">#</a> Tips</h3> <p>​有时候需要不那么精确的资源标记验证方法。例如，某服务器想对一个很大且被广泛缓存的资源做微小的修改，但又不想再缓存服务器再验证时产生很大的传输流量。该情况下，服务器可以在标记前面家上 <code>W/</code> 来广播一个“弱”实体标记。对于弱实体标记，只有关联的资源发生 <strong>重大改变</strong> 时，标记才会变化。而强实体标记则不管实体发生什么性质变化，标记都一定会改变。</p></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/app.3d620a6f.js" defer></script><script src="/assets/js/2.fe4a76b1.js" defer></script>
  </body>
</html>
